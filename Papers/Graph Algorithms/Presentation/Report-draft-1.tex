\documentclass[a4paper,10pt]{article}

\usepackage{geometry}
\geometry{
    a4paper,
    left=1cm,
    right=1cm,
    top=1cm,
    bottom=2cm}
\usepackage{xepersian}
\settextfont{Vazirmatn-Regular.ttf}


\title{گزارش الگوریتم تکاملی مبتنی بر متقاطع یکپارچه برای رنگ‌آمیزی نمودارهای دارای وزن راس}
\author{محمد خورشیدی روزبهانی\\40215741002013 \and شارا شاهوردیان\\40215741002032}
\date{}

\linespread{1.5}

\begin{document}

    \maketitle
    
    \vspace{0.5cm}

    \begin{abstract}

        رنگ‌آمیزی نمودار یکی از مسائل اصلی بهینه‌سازی است که به طور گسترده در ادبیات مورد مطالعه قرار گرفته است. در این مطالعه، یک الگوریتم تکاملی نوآورانه به نام الگوریتم تکاملی مبتنی بر متقاطع یکپارچه با عملگر متقاطع منحصر به فرد خود و تکنیک جستجوی محلی برای رنگ‌آمیزی نمودارهای دارای وزن راس پیشنهاد می‌شود. عملگر متقاطع یکپارچه به منظور استفاده از اطلاعات خاص حوزه در افراد و تکنیک جستجوی محلی به منظور کاوش در حلقه‌های مجاور با استفاده از عملیات‌های تعویض وزن هدفمند می‌باشد. عملکرد کار پیشنهادی بر روی مجموعه داده‌های مصنوعی و نمونه‌های DIMACS با مقایسه آن با الگوریتم‌های تکاملی پیشرو از ادبیات ارزیابی می‌شود. مطالعه تجربی نشان می‌دهد که الگوریتم ما در ۷۱٪ موارد آزمایشی بهتر از کار مرتبط عمل کرده است و در ۱۷٪ موارد آزمایشی مصنوعی به نتیجه مشابهی می‌رسد. آزمایش‌های انجام شده بر روی نمونه‌های DIMACS نشان می‌دهد که الگوریتم ما تعداد بهترین رنگ‌ها را در 70 از 73 نمودار پیدا می‌کند، بنابراین کار پیشنهادی در زمان معقول موفق به رنگ‌آمیزی نمودارهای دارای وزن راس می‌شود.
    
    \end{abstract}

    \section{مقدمه}

        نظریه رنگ‌آمیزی نمودار به تقسیم یک مجموعه از راس‌ها به کلاس‌های رنگی جداگانه تحت شرطی می‌پردازد که هیچ راسی که یال مشترکی دارد نمی‌تواند به یک کلاس تخصیص یابد. هدف مسئله کلاسیک رنگ‌آمیزی نمودار، تعیین کوچکترین مقدار رنگ k برای به‌دست آوردن یک راه‌حل قانونی است. مسئله k-رنگ‌آمیزی نمودار (k-GCP) سعی دارد یک رنگ‌آمیزی ممکن برای یک نمودار با یک مقدار داده شده k پیدا کند. اگر راه‌حل بدون تضاد باشد، آنگاه یک k-رنگ‌آمیزی قانونی به‌دست می‌آید. مسئله رنگ‌آمیزی نمودار می‌تواند با حل یک سری مسائل k-رنگ‌آمیزی حل شود. با شروع با یک مقدار k کافی بزرگ، مقدار k می‌تواند هر بار که یک رنگ‌آمیزی قانونی پیدا شود، کاهش یابد. این فرایند تکرار می‌شود تا زمانی که یک راه‌حل غیرقانونی به‌دست آید. هدف اصلی k-GCP کمینه‌سازی تعداد یال‌های تضادی برای یک مقدار ثابت k است.

        مسائل رنگ‌آمیزی نمودار با اهداف مختلفی وجود دارند. مسئله رنگ‌آمیزی متقارن [1] شامل یک رنگ‌آمیزی قانونی با اختصاص رئوس به k کلاس رنگی مستقل است که تعداد رئوس در این کلاس‌ها حداکثر می‌تواند یکی اختلاف داشته باشد، در حالی که هدف مسئله کمینه‌سازی جمع رنگ‌های اختصاص یافته به رئوس است. همچنین، وزن‌ها می‌توانند به رئوس در مسائل رنگ‌آمیزی نمودار اضافه شوند [2]. هدف مسئله رنگ‌آمیزی رأسی وزن‌دار، به‌دست آوردن یک رنگ‌آمیزی قانونی k-رنگی با هدف کمینه‌سازی جمع هزینه‌های کلاس‌های رنگ آن است. هزینه یک کلاس رنگی توسط رأسی که وزن بیشتری در کلاس دارد، تعیین می‌شود.

        مسئله رنگ‌آمیزی نمودار به طور معمول برای مدل‌سازی مسائل واقعی مانند برنامه‌ریزی زمان، تخصیص منابع و تخصیص ثبت‌ها [3]–[5] استفاده می‌شود. اکثر این مسائل دارای تعداد محدودی منابع هستند. از آنجا که k-رنگ‌آمیزی مقدار رنگ ثابت k را در نظر می‌گیرد، این مقدار می‌تواند به تعداد منابع موجود در سیستم اشاره کند، بنابراین k-رنگ‌آمیزی می‌تواند برای حل این مسائل استفاده شود. در اکثر موارد، تعداد رنگ‌ها، k، ممکن است کافی نباشد تا یک رنگ‌آمیزی قانونی به‌دست آید، بنابراین برخی از رئوس بدون رنگ خواهند ماند. اهمیت رئوس ممکن است برابر نباشد، بنابراین از یک مقدار وزن برای نشان دادن اهمیت آن‌ها استفاده می‌شود. کار پیشنهادی ما مسئله k-رنگ‌آمیزی (k-GCP) را با استفاده از یک گراف دارای وزن رأسی با هدف کمینه‌سازی جمع وزن کل رئوس بدون رنگ برای یک مقدار داده شده k در نظر می‌گیرد. مسئله k-رنگ‌آمیزی رأسی با وزن از یک گراف بدون جهت و دارای وزن G=(V،E،w) استفاده می‌کند، که در آن V مجموعه رئوس را نشان می‌دهد، E مجموعه یال‌ها را نشان می‌دهد و w مجموعه مقادیر وزن رئوس در V است که تاکیدی بر اهمیت آن‌ها دارند. هدف k-GCP انجام رنگ‌آمیزی رئوس در V با استفاده از یک تعداد پیش‌تعریف شده از رنگ‌ها است. اگر تعداد داده شده از رنگ‌ها نتواند همه رئوس را رنگ‌آمیزی کند، برخی از رئوس بدون رنگ خواهند ماند. رئوس بدون رنگ به عنوان رئوس تضادی تعریف می‌شوند. تابع تناسب f (k) برابر با جمع وزن کل رئوس بدون رنگ هنگام استفاده از یک تعداد پیش‌تعریف شده از k رنگ است. هدف k-GCP کمینه‌سازی مقدار تابع تناسب f (k) است.

        مسئله رنگ‌آمیزی نمودار به عنوان یک مسئله NPComplete اثبات شده است [6] و بسیاری از روش‌های هیوریستیکی برای مسئله رنگ‌آمیزی نمودار [7]–[11]، مسئله رنگ‌آمیزی متقارن [12]، [13]، مسئله k-رنگ‌آمیزی [14]، [15]، مسئله کمینه‌سازی جمع رنگ‌ها [16] و مسئله رنگ‌آمیزی رأسی وزن‌دار [17] در ادبیات پیشنهاد شده‌اند. در این مطالعه، یک الگوریتم تکاملی ترکیبی [18] برای مسئله k-رنگ‌آمیزی رأسی وزن‌دار پیشنهاد می‌شود. الگوریتم ما به نام الگوریتم تکاملی مبتنی بر متقاطع یکپارچه (InCEA) با عملگر متقاطع جدید خود و تکنیک جستجوی محلی است. عملگر متقاطع یکپارچه گروه بیشینه‌ای از رئوس بدون تضاد را به کلاس‌های رنگی فرزندان با استفاده موفقیت‌آمیز از اطلاعات خاص مسئله در والدین تقسیم می‌کند. دو کلاس رنگی انتخاب شده به‌طور تصادفی از والدین به‌طور تدریجی ترکیب می‌شوند تا هر کلاس رنگی از فرزندان شکل گیرد. رئوس تضادی به استخر انداخته می‌شوند و هر بار که یک کلاس رنگی جدید از فرزندان ایجاد می‌شود، رئوس در استخر امتحان خود را برای پیدا کردن یک کلاس رنگی بدون تضاد می‌دهند. اگر در پایان عملگر متقاطع، رئوسی در استخر موجود باشند، تکنیک جستجوی محلی سعی می‌کند این رئوس را به یکی از کلاس‌های رنگی فرزندان با استفاده از یک عملیات تعویض وزن‌دار قرار دهد تا مقدار تابع تناسب کمینه شود.

        در مطالعه تجربی ما، الگوریتم InCEA را با کارهای مرتبط از ادبیات مقایسه کردیم. نتایج به دست آمده از مجموعه داده‌های مصنوعی تولید شده و نمونه‌های DIMACS نشان می‌دهد که InCEA در بیشتر موارد آزمایشی از نظر مقادیر تناسب و زمان محاسبات عملکرد کارهای مرتبط را برتری می‌بخشد. عملکرد الگوریتم‌ها بر روی ۷۳ نمونه DIMACS که گراف‌های چالش برای مسئله رنگ‌آمیزی نمودار هستند، نیز در این مطالعه ارائه شده است. از آنجا که تعداد کمینه رنگ‌های مورد نیاز برای رنگ‌آمیزی گراف‌ها برای این بنچمارک‌ها در ادبیات پیدا نشده است، این مقاله همچنین کمینه تعداد رنگ‌های استفاده شده برای رنگ‌آمیزی این نمونه‌ها را گزارش می‌دهد. همانطور که در مطالعه تجربی اشاره شده، الگوریتم تکاملی ما می‌تواند در بیشتر موارد آزمایشی ارائه شده به سرعت بسیار خوبی نتایج بهتری را نسبت به الگوریتم‌های موجود در ادبیات به دست آورد.

        مهم‌ترین مشارکت‌های این کار می‌تواند به شرح زیر باشد:

        \begin{itemize}
            
            \item عملگر متقاطع یکپارچه به منظور استفاده از اطلاعات خاص مسئله در افراد با کمک یک استخر و یک عملیات جستجوی معکوس هدفمند استفاده می‌شود.

            \item عملیات تعویض وزن‌دار در تکنیک جستجوی محلی به منظور کاوش در حلقه‌های مجاور و افزایش فرصت برای رسیدن به بیشینه جهانی هدفمند است.

            \item هیچ محاسبات اضافی برای تکنیک جستجوی محلی یا محاسبه تناسب لازم نیست زیرا استخر از قبل رأس(های) بدون رنگ را نگه می‌دارد، بنابراین الگوریتم از بار جستجوهای جامع خلاص می‌شود.

        \end{itemize}

        در بقیه مقاله، ابتدا مطالعات مرتبط و تعریف مسئله مسئله k-رنگ‌آمیزی به ترتیب در بخش‌های 2 و 3 ارائه می‌شوند. در بخش 4، جزئیات اجزای کار پیشنهادی ما را توضیح می‌دهیم. سپس، عملکرد الگوریتم ما را با الگوریتم‌های موجود در ادبیات بر روی نمونه‌های آزمایشی مختلف در بخش 5 مقایسه و بررسی می‌کنیم. در نهایت، خلاصه کار پیشنهادی خود را ارائه می‌دهیم و پیشنهاداتی برای جهت‌های آینده ممکن را در بخش 6 ارائه می‌دهیم.

    \section{کار مرتبط}

        بسیاری از مسائل واقعی مانند برنامه‌ریزی زمان، تخصیص ثبت‌ها و تخصیص منابع می‌توانند با مسئله رنگ‌آمیزی نمودار نمایش داده شوند، جایی که رئوس معرفی‌کننده اشیاء و یال‌ها محدودیت‌ها را نشان می‌دهند. در تمام این مسائل، تعداد محدودی از منابع (رنگ‌ها) وجود دارد، بنابراین برخی از رئوس بدون رنگ خواهند ماند. وزن‌ها می‌توانند به رئوس اضافه شوند تا اهمیت آن‌ها را نشان دهند، و یک گراف دارای وزن رأسی می‌تواند برای مدل‌سازی این مسائل استفاده شود.

        در مسئله تخصیص ثبت‌ها [19]، هدف این است که حداکثر تعداد متغیرها را به حداقل تعداد ثبت‌ها اختصاص داد تا متغیرها به سرعت بالایی توسط واحد پردازش مرکزی (CPU) دسترسی داشته باشند. مسئله می‌تواند با استفاده از یک گراف بدون جهت نمایش داده شود، جایی که متغیرها توسط رئوس نشان داده می‌شوند و مداخلات بین متغیرها توسط یک یال نشان داده می‌شود. هدف این مسئله کمینه کردن تعداد ثبت‌های استفاده شده (رنگ‌ها) و انتخاب متغیرهایی است که کمتر دسترسی دارند، که می‌تواند به طور مستقیم برای انتخاب رئوس بدون رنگ و محاسبه تابع تناسب در k-GCP [20] اعمال شود.

        مسئله تخصیص منابع نیز می‌تواند با استفاده از k-GCP حل شود. یکی از مهم‌ترین مسائل تخصیص منابع در شبکه‌های کامپیوتری [21]–[25]، تخصیص پهنای باند در شبکه‌های بی‌سیم است. در این مسئله، شبکه با سنسورهای خود می‌تواند به عنوان یک گراف بدون جهت و رئوس نمایش داده شود. اگر فاصله بین دو سنسور بیشتر از یک حد پیش‌تعیین شده باشد، این سنسورها نمی‌توانند از همان باند استفاده کنند، بنابراین رئوس نماینده آنها توسط یک یال متصل می‌شوند. هدف این مسئله کمینه کردن تعداد باندها (رنگ‌ها) برای تمامی سنسورها است. همچنین وزن رئوس کیفیت سنسورها را نشان می‌دهد.

        برنامه‌ریزی یک مسئله چالش‌برانگیز برای آموزش [26]، محاسبات [27]، تولید [28] و ارتباطات [29]، [30] است. به طور کلی، مسائل بر روی یک عنصر مانند یک دانش‌آموز، یک تولید، یک کارمند یا یک کار با ویژگی‌های مختلف خود تمرکز دارند. عناصر به عنوان رئوس نمایش داده می‌شوند و تضادها بین این عناصر با یال‌ها در گراف نمایش داده می‌شوند. اهمیت عناصر با وزن رئوس نشان داده می‌شود. زمان، ماشین‌ها، منابع، وسایل نقلیه به عنوان رنگ‌ها استفاده می‌شوند و تابع هدف می‌تواند بیشینه‌سازی کارایی زمانی، بهره‌وری منابع و غیره باشد. بنابراین، مسئله رنگ‌آمیزی نمودار یک انتخاب مناسب برای مسائل برنامه‌ریزی است [31].

        هنگامی که مسائل واقعی با استفاده از مسئله رنگ‌آمیزی نمودار مدل‌سازی می‌شوند، بسیاری از روش‌های دقیق [32]–[34] و هیوریستیک [35]–[38] به دلیل پیچیدگی NP-Hard آن [6], [39], [40] قابل استفاده هستند. اگرچه الگوریتم‌های دقیق پیشنهادی برای حل مسئله رنگ‌آمیزی نمودار [41] می‌توانند بهترین راه‌حل‌ها را برای نمونه‌های کوچک پیدا کنند، اما برای نمونه‌های بزرگ هزینه زیادی از نظر مصرف حافظه و زمان دارند [42].

        الگوریتم تکاملی یکی از روش‌های هیوریستیک برای مسئله رنگ‌آمیزی نمودار است [2]. الگوریتم‌های تکاملی فرایند طبیعی را با عملگرهای متقاطع و جهش شبیه‌سازی می‌کنند. این الگوریتم‌ها با یک جمعیت سر و کار دارند که تعداد پیش‌تعریف شده‌ای از راه‌حل‌های کاندید که به عنوان افراد برای یک گراف دارای وزن رأسی داده شده، نگه داشته می‌شوند [43].

        در ادبیات، الگوریتم‌های تکاملی وجود دارند که مسائل واقعی را که به k-GCP رمزگذاری شده‌اند را حل می‌کنند، مانند الگوریتم تکاملی ترکیبی (HEA) [44] و الگوریتم ممتاز به منظور هزینه (COMA) [45].

        HEA و COMA جمعیت اولیه خود را با استفاده از سه معیاری که در [44] پیشنهاد شده‌اند، ایجاد می‌کنند. جزئیات این معیارها در بخش IV-A ذکر شده است. هنگامی که جمعیت‌های اولیه ایجاد شدند، هر دو HEA و COMA اپراتورهای متقاطع خود را برای بهبود افراد خود اعمال می‌کنند. الگوریتم‌ها دو والدین را از جمعیت خود انتخاب کرده و کلاس‌های رنگی این والدین را ترکیب می‌کنند تا فرزندی ایجاد کنند. انتخاب کلاس‌های رنگ در این الگوریتم‌ها متفاوت است. HEA از عملگر تقسیم بدون تضاد (CFPX) استفاده می‌کند که کلاس‌های رنگ را با بیشترین زیرمجموعه رأس بدون تضاد انتخاب می‌کند. از سوی دیگر، COMA کلاس رنگ را با بیشترین وزن زیرمجموعه بدون تضاد انتخاب می‌کند و عملگر متقاطع آن به نام عملگر تقاضای گرایی هزینه (COPX) است.

        فرزندانی که توسط CFPX یا COPX ایجاد می‌شوند، تضمین نمی‌کنند که یک راه‌حل بدون تضاد تولید کنند. HEA و COMA اپراتور جستجوی محلی را که در [44] پیشنهاد شده است، اعمال می‌کنند. آنها یکی از رأس‌های تضادی را از یک کلاس رنگی از فرزند با استفاده از مقادیر درجه و وزن رأس‌ها انتخاب می‌کنند. هر دو الگوریتم تمامی کلاس‌های رنگ را برای قرار دادن این رأس تضادی بازدید می‌کنند و آن را به کلاس رنگی اختصاص می‌دهند که باعث بیشینه کاهش در مقدار تابع تناسب شود. تعداد ایتریشن‌ها در این مرحله جستجو به ۱۰٪ از کل تعداد تضادها در HEA محدود شده است، در حالی که COMA چنین محدودیتی ندارد و برای هر رأس تضادی در فرزند تمامی کلاس‌های رنگ را بازدید می‌کند. تکنیک‌های مبتنی بر تضاد و مبتنی بر هزینه در HEA معرفی شده‌اند، و کمترین مقدار تابع تناسب به دست آمده از این دو رویکرد به عنوان مقدار تابع تناسب فرزند انتخاب می‌شود. در حالی که COMA از تکنیک‌های مبتنی بر تضاد، مبتنی بر هزینه و مبتنی بر معیار استفاده می‌کند تا مقدار تابع تناسب فرزند را محاسبه کند.

    \section{بیان مسئله}

        گراف وزن‌دار بدون جهت $G(V,E,w)$ را در نظر بگیرید، جایی که $V$ و $E$ مجموعه‌های رئوس و یال‌ها هستند، و $w$ مجموعه‌ی مقادیر وزن رئوس شامل $V$ است. اگر $V$ دارای $n$ راس باشد، اندازه مجموعه وزن، $|w|$، همچنین $n$ است و $E$ حداکثر می‌تواند 
        $\frac{n \times (n-1)}{2}$
        یال داشته باشد، که
        $0 \leq |E| \leq \frac{n \times (n-1)}{2}$

        هر رأس $v \in V$ به یک کلاس رنگ $C_i$ تعلق دارد، که یکی از مجموعه‌های مستقل جدایی شده از 
        $C = \{C_1, C_2, C_3, \dots, C_k\} $
        است، به طوری که
        $1 \leq k \leq n$.

        اگر $u \in V$ مجاور $v \in V$ باشد، در این صورت یک یال $\{u, v\} \in E$ وجود دارد و $u$ و $v$ نمی‌توانند در یک رنگ باشند (1). این به عنوان رنگ‌آمیزی قانونی یا k-ممکن شناخته می‌شود.
        
        \vspace{-0.5cm}

        \begin{equation} 
            \forall v, \hspace{1em} u \in C_i, \{u, v\} \notin E, \hspace{1em} i = 1, 2, 3, \dots, k
        \end{equation}

        برای یک مقدار داده شده از تعداد کلاس‌های رنگ $k$، هدف مسئله k-رنگ‌آمیزی ارائه یک کلاس رنگ برای هر رأس $v$ به گونه‌ای است که شرط (1) را رعایت کرده و یک رنگ‌آمیزی ممکن ارائه دهد. اگر $v$ نتواند به یک کلاس رنگ اختصاص یابد، آنگاه $v$ به عنوان یک رأس تضادی تعریف شده و غیررنگ‌آمیزی می‌شود. در این صورت، راه‌حل غیرقابل اجرا است و هدف مسئله k-رنگ‌آمیزی کمینه کردن مجموع وزن‌های رأس‌های تضادی با استفاده از $f(k)$ است (2).

        \vspace{-0.5cm}

        \begin{equation}
            minimize \hspace{0.5em} f(k) = \sum w(v), \hspace{1em} v \notin C
        \end{equation}

    \section{الگوریتم تکاملی مبتنی بر متقاطع یکپارچه}

        روش عمومی رویکرد ما بر مبنای الگوریتم ژنتیک به صورت کلی در الگوریتم 1 آورده شده است. در هر نسل از الگوریتم، ترکیب یکپارچه (InCX) انجام می‌شود که در الگوریتم 2 ارائه شده است. به عنوان یک قسمت از اپراتور ترکیب، عملیات جستجو به عقب که در الگوریتم 3 آمده است، انجام می‌شود. بر اساس خروجی اپراتور ترکیب، که یک فرزند تکی است، کار ما به بهبود فرزند با استفاده از تکنیک جستجوی محلی که در الگوریتم 4 ارائه شده است، هدفمند است.

        الگوریتم 1

        الگوریتم 2

        الگوریتم 3

        الگوریتم 4

        \subsection{نمایندگی انفرادی و نسل اولیه جمعیت}

            در الگوریتم پیشنهادی، هر فرد $S_i$ در جمعیت با روش تقسیم [46] نمایش داده می‌شود که
            $S_i = \{C_1, C_2, C_3, \dots, C_k\}$
            است و هر کلاس رنگ $C_j$ شامل یک گروه از رئوس بدون تضاد است با در نظر گرفتن مجموع $k$ کلاس رنگ.

            جمعیت اولیه شامل تعداد پیش‌تعیین شده‌ای از راه‌حل‌های کاندیدایی است که با استفاده از معیار درجه لکه [44] ایجاد شده‌اند، که رئوس را به سه روش مختلف مرتب می‌کند. معیار درجه لکه از وزن رئوس، $w(v_i)$، و درجه رئوس که با $d(v_i)$ نشان داده می‌شود، استفاده می‌کند. برای تنوع در جمعیت، درجات لکه برای 40٪، 40٪ و 20٪ از کل رئوس با استفاده از (3الف، 3ب و 3ج)، به ترتیب، تنظیم می‌شود.

            \vspace{-0.5cm}

            \begin{equation}
                S_1 (v_i) = w(v_i) \times d(v_i)
            \end{equation}

            \vspace{-1cm}

            \begin{equation}
                S_2 (v_i) = w(v_i) \times d(v_i)^2
            \end{equation}

            \vspace{-1cm}

            \begin{equation}
                S_3 (v_i) = w(v_i)
            \end{equation}

            رئوس بر اساس درجه لکه خود به ترتیب نزولی مرتب می‌شوند و به کلاس‌های رنگی فردانشان اضافه می‌شوند. برای تولید هر فرد، رأس با بیشترین درجه لکه از مجموعه‌ی رئوس ناشده انتخاب شده و به یک کلاس رنگ اضافه می‌شود. از اولین کلاس رنگ شروع شده و الگوریتم یک کلاس رنگ را پیدا می‌کند که رأس یک مجموعه بدون تضاد با سایر رئوسی که به همان کلاس تعلق دارند، فراهم می‌کند. رأس به اولین کلاس رنگ بدون تضاد اختصاص داده می‌شود. اگر هیچ کلاسی برای چنین رأسی یافت نشود، رأس به یک کلاس رنگ تصادفی اضافه می‌شود. این فرایند تکرار می‌شود تا همه‌ی رئوس به یک کلاس رنگ نگاشته شوند.

        \subsection{اپراتور متقاطع یکپارچه}

            در این کار، ما یک اپراتور ترکیب جدید ارائه می‌دهیم که هدف آن راهنمایی افراد برای رسیدن به بهینه جهانی با اطلاعات خاص مسئله در کلاس‌های رنگی می‌باشد. هدف از اپراتور ترکیب یکپارچه این است که کلاس‌های رنگی را از والدین ترکیب کرده و تعداد رئوس بدون تضاد را در هر کلاس رنگ افزایش دهد، به گونه‌ای که تعداد کل رئوس بدون رنگ بیشینه شود.

            دو کلاس رنگ از والدین انتخاب شده و ترکیب می‌شوند تا احتمال یافتن یک گروه بزرگتر و بهتر از رئوس بدون تضاد افزایش یابد. اپراتور ترکیب یکپارچه ما یک استخر را برای نگه داشتن رئوس تضادی که نمی‌توانند به کلاس رنگی فعلی تعلق گیرند، پیشنهاد می‌دهد. فرزندان به طور معمول بیش از یک کلاس رنگ خواهند داشت، بنابراین رئوسی که به استخر پرتاب شده‌اند، فرصتی برای قرار گرفتن در کلاس‌های رنگی ایجاد شده پیش از این خواهند داشت. از طرف دیگر، اپراتور ترکیب یکپارچه ما یک عملیات جستجو به عقب برای کمینه کردن تعداد رئوس باقی‌مانده در استخر دارد که با قرار دادن رئوس در استخر به یک کلاس رنگی بدون تضاد، انجام می‌شود.

            تحقیقات قبلی در ادبیات کلاس رنگ از یکی از والدین کلاس رنگ با بیشترین مجموعه بدون تضاد را انتخاب کرده و این مجموعه مستقیماً به فرزندان کپی می‌شود. آن‌ها در نظر نگرفتند که اطلاعات خاص مسئله را در هر دو کلاس رنگ به دلیل تضادها ترکیب کنند.

            \subsubsection{اپراتور متقاطع مبتنی بر استخر}

                اپراتور ترکیب یکپارچه با انتخاب تصادفی دو تنظیمات والدین شروع می‌شود که والد اول و والد دوم به ترتیب با
                $S_1 = \{C_{0}^{1}, C_{1}^{1}, C_{2}^{1}, \dots, C_{k-1}^{1}\}$
                و
                $S_2 = \{C_{0}^{2}, C_{1}^{2}, C_{2}^{2}, \dots, C_{k-1}^{2}\}$
                نشان داده می‌شوند در الگوریتم ترکیب (مراجعه به الگوریتم 2). اپراتور یک فرزند
                $S_0 = \{C_0, C_1, C_2, \dots, C_{k-1}\}$
                را ایجاد می‌کند و یک استخر $P$ را آماده می‌کند که همچنین توسط تکنیک جستجوی محلی استفاده خواهد شد.

                اپراتور ترکیب یکپارچه به صورت تکراری فرزندان را ایجاد می‌کند و در هر تکرار یک کلاس رنگ از فرزند که به عنوان $Ci$ نمایش داده می‌شود، با استفاده از دو تقسیم تصادفی $C_{x}^{1}$ و $C_{y}^{2}$ از هر دو والد ایجاد می‌شود. رئوس در این تقسیم‌بندی‌ها گروه‌بندی شده و کلاس رنگی از فرزند با رئوس بدون تضاد ایجاد می‌شود. اگر رئوس تضادی وجود داشته باشند که نمی‌توانند به کلاس رنگ فعلی اختصاص یابند، الگوریتم سعی می‌کند این رئوس را به کلاس‌های رنگی از پیش تولید شده فرزند $S_0$ با استفاده از عملیات جستجو به عقب اختصاص دهد که در زیر بخش بعدی به تفصیل شرح داده شده است. اگر چنین کلاس رنگی وجود نداشته باشد، آن‌ها به استخر پرتاب می‌شوند تا با رئوسی که در تکرارهای بعدی انتخاب می‌شوند ترکیب شوند.
            
            \subsubsection{عملیات جستجو در عقب}

                در کار اولیه ما، الگوریتم تکاملی مبتنی بر استخر (PBEA) [47]، ما یک استخر ابتدایی برای ذخیره رئوسی که به کلاس‌های رنگی تخصیص نیافته‌اند، پیشنهاد دادیم. حتی اگر برخی از رئوس در استخر بتوانند به کلاس‌های رنگی از فرزندانی که در تکرارهای قبلی تولید شده‌اند تخصیص داده شوند، مکانیزم هوشمندی برای شناسایی آنها پیشنهاد نشده بود. به عبارتی، نگهداری از استخر به مشکل خواهد خورد زیرا رئوس تضادی جدید در هر تکرار به آن اضافه می‌شوند.

                در این مطالعه، ما عملیات جستجو به عقب را به همراه استخر به عنوان بخشی از اپراتور ترکیب یکپارچه پیشنهاد می‌دهیم. عملیات جستجو به عقب هدفش حذف رئوسی است که با کلاس‌های رنگی از پیش تولید شده تضاد ندارند. به عبارت دیگر، این عملیات تعداد رئوس بدون تضاد را در هر کلاس رنگ افزایش می‌دهد و تعداد رئوس موجود در استخر را کاهش می‌دهد.

                برای توضیح اجرای اپراتور ترکیب یکپارچه ما (InCX)، یک نمونه گراف وزن‌دار و دو تنظیم والدین را در شکل 1 و شکل 2 در نظر می‌گیریم، به ترتیب. توجه داشته باشید که همان گراف و والدین در یک کار قبلی [44] ارائه شده‌اند.

                عکس 1

                از گام 0 شروع می‌کنیم، کلاس رنگ دوم $C_1^1$ از والد اول $S_1$ و کلاس رنگ سوم $C_2^2$ از والد دوم $S_2$ به صورت تصادفی انتخاب می‌شوند. رئوس 2، 7، 8 در $C_1^1$ و رئوس 0، 1، 9 در $C_2^2$ ترکیب شده و به کلاس رنگ اول $C_0$ از فرزند $S_0$ اضافه می‌شوند. این رئوس به عنوان تخصیص داده شده علامت‌گذاری شده و از کلاس‌های رنگی والدین حذف می‌شوند که در مراحل بعدی رئوس نامرئی برای مراحل بعدی شوند. تضادهای بین رئوس در $C_0$ بر اساس گراف در شکل 1 محاسبه می‌شوند. بیشترین رئوس دارای تضاد با 3 تضاد، رئوس 8 است بنابراین به طور مستقیم در استخر $P$ انداخته می‌شود. رئوس 8 سه یال با رئوس 1، 2 و 9 دارد. پس از حذف رئوس 8 از $C_0$، تضادهای رئوس 1، 2 و 9 به ترتیب یک واحد کاهش می‌یابد. رئوس 2، 7 و 1 بیشترین تعداد تضادها را دارند، بنابراین ارزش‌های وزن آن‌ها (در شکل 1) مقایسه می‌شوند. از آنجا که رئوس 7 ارزش وزن کمتری با ارزش وزن 1 دارد، به عنوان رئوس با بیشترین تضاد انتخاب می‌شود و به استخر $P$ انداخته می‌شود و از $C_0$ حذف می‌شود. رئوس باقی‌مانده با تضاد تنها رئوس 0 و 1 هستند، جایی که رئوس 1 به استخر $P$ انداخته می‌شود و به دلیل داشتن وزن کمتر از $C_0$ حذف می‌شود. $C_0$ بدون تضاد می‌شود و اولین تکرار ترکیب پایان می‌پذیرد.

                در تکرار بعدی، کلاس‌های رنگ اول $C_0^1$ و $C_0^2$ از والدین به صورت تصادفی انتخاب می‌شوند. رئوس بی‌نسبت 3، 4 و 6 در $(C_0^1 \cup C_0^2)$ به عنوان تخصیص داده شده به کلاس رنگ دوم $C_1$ از $S_0$ اضافه می‌شوند و علامت‌گذاری می‌شوند. رئوس 8، 7 و 1 در $P$ نیز با رئوس در $C_1$ ترکیب می‌شوند. تضادهای رئوس محاسبه می‌شود و رئوس 3، 8 و 6 به $P$ انداخته می‌شوند تا کلاس رنگ $C_1$ بدون تضاد شود. از آنجا که فرزند $S_0$ یک کلاس رنگی $C_0$ را قبلاً تولید کرده است، رئوس بی‌نسبت در استخر $P$ فرصتی برای قرارگیری در $C_0$ دارند. عمل جستجوی باز به قرار دادن رئوس در $P$ به $C_0$ ادامه می‌دهد. رئوس 3 با رئوس 0 تضاد دارد، رئوس 8 با رئوس 2 و 9 تضاد دارد، بنابراین آن‌ها در $P$ نگه داشته می‌شوند. با این حال، رئوس 6 با رئوس در $C_0$ تضادی ندارد، بنابراین به $C_0$ نقشه‌برداری می‌شود. در تکرار نهایی، دو کلاس رنگ باقیمانده که قبلاً انتخاب نشده‌اند به عنوان $C_2^1$ و $C_1^2$ انتخاب می‌شوند. در هر دو کلاس رنگ، تنها یک رئوس بی‌نسبت وجود دارد که رئوس 5 است، بنابراین با رئوس 3 و 8 در دسترس در $P$ ترکیب شده و به کلاس رنگ سوم $C_2$ از $S_0$ اضافه می‌شوند. بر اساس گراف داده شده در شکل 1، یک مجموعه بدون تضاد برای $C_2$ به دست می‌آید. با تولید تعداد از پیش تعریف شده کلاس‌های رنگ (که در اینجا $k = 3$ است) برای $S_0$، عملیات ترکیب به پایان می‌رسد.

                در پایان عملیات ترکیب یکپارچه، یک فرزند $S_0$ با 3 کلاس رنگ و یک استخر $P$ به دست می‌آید. زمانی که $P$ شامل رئوس بی‌نسبت است، به این معناست که گراف داده شده نمی‌تواند با $k$ رنگ رنگ‌آمیزی شود و روش جستجوی محلی پیشنهادی که در بخش 4.2.2 توضیح داده شده، به $S_0$ و $P$ اعمال می‌شود. در غیر این صورت، الگوریتم پیشنهادی با موفقیت تمام رئوس را رنگ‌آمیزی کرده است، بنابراین نیازی به اعمال روش جستجوی محلی نیست. یک سناریوی مثال در شکل 2 نشان داده شده است.

                برای گراف وزن‌دار مثال داده شده در شکل 1، خروجی عملیات ترکیب یکپارچه ما (InCX) و سه خروجی از عملیات‌های ترکیبی ارائه شده در ادبیات در شکل 3 نشان داده شده است، که شامل ترکیب بخشریزی بی‌تضاد (CFPX)، ترکیب هزینه‌مند (COPX) و ترکیب مبتنی بر استخر (PBC) هستند. فرزندان تولیدشده توسط CFPX، COPX و PBC هنوز رئوس بی‌رنگی دارند. CFPX و PBC نمی‌توانند رأس 6 را رنگ‌آمیزی کنند که وزن آن 3 است. COPX قادر به رنگ‌آمیزی رأس 3 نیز نبود که وزن آن 1 است. با این حال، InCX موفق به رنگ‌آمیزی همه رئوس می‌شود بدون اعمال روش جستجوی محلی.

                CFPX و COPX همیشه کلاس‌های رنگی را انتخاب می‌کنند که دارای بیشترین زیرمجموعه بدون تضاد هستند، در حالی که PBC و InCX کلاس‌های رنگی را به صورت تصادفی از هر دو پدر انتخاب می‌کنند، بنابراین راه‌حل‌ها می‌توانند از ترکیب‌های مختلفی به دست آیند. در شکل 2، PBC و InCX می‌توانند کلاس‌های رنگی از پدرها را به 36 روش مختلف ترکیب کنند و از این ترکیبات 36 راه‌حل بدست آورند. PBEA می‌تواند از 50٪ از این ترکیبات یک راه‌حل بدون تضاد پیدا کند، 22٪ از راه‌حل‌های بدون تضاد پس از PBC و 28٪ از آنها پس از عملگر جستجوی محلی آن پیدا می‌شوند. در حالی که، InCEA می‌تواند از 58٪ از این ترکیبات یک راه‌حل بدون تضاد بدست آورد و 55٪ از این راه‌حل‌های بدون تضاد پس از عملگر InCX پیدا می‌شوند. این درصدها نشان می‌دهد که عملگر ترکیب جدید ما احتمال یافتن یک راه‌حل بدون تضاد را افزایش می‌دهد.

        \subsection{تکنیک جستجوی محلی}
            
            هدف از عملگر InCX کسب بزرگترین گروه‌های رأس بدون تضاد در هر کلاس رنگی از فرزند است. هنگام انتقال رئوس تضادی به استخر، ارزش‌های وزنی رئوس تنها در مواقعی مدنظر قرار می‌گیرد که نیاز به تصمیم‌گیری در میان بیش از دو رأس با تعداد تضاد یکسان وجود دارد. در پایان عملگر ترکیب یکپارچه ما، اگر هنوز رئوسی در استخر وجود داشته باشد، این رئوس حداقل با یکی از رئوس هر کلاس رنگی از فرزند تضاد دارند و ممکن است راه‌حلی بدون تضاد وجود نداشته باشد.

            هدف الگوریتم ما کمینه کردن وزن کل رئوسی است که نمی‌توانند رنگ‌آمیزی شوند. از آنجا که عملگر InCX وزن رئوس را در نظر نمی‌گیرد، تکنیک جستجوی محلی هدفش کاهش مجموع وزن رئوسی است که رنگ‌آمیزی نشده‌اند با در نظر گرفتن راه‌حل‌های مجاور. در پایان عملگر ترکیب، رئوسی که رنگ‌آمیزی نشده‌اند در استخر حضور دارند، بنابراین تکنیک جستجوی محلی سعی می‌کند این رئوس را با عملیات جابجایی به کلاس‌های رنگی منتقل کند.

            الهام گرفته شده از عملگر جهش سنتی SWAP که موقعیت دو ژن انتخاب شده را در نمایش ژن مبتنی بر ترتیب تعویض می‌کند، یک تکنیک جستجوی محلی جدید به نام Weighted-Swap (W-SWAP) پیشنهاد می‌دهیم. W-SWAP شامل جستجو و تعویض رئوس بین استخر و کلاس‌های رنگی است. اگر مجموع وزن رئوسی که قرار است از یکی از کلاس‌های رنگی جابجا شوند، کمتر از وزن رئوس در استخر باشد، عملیات جابجایی انجام می‌شود. در پایان جستجوی محلی، مجموع وزن رئوسی که رنگ‌آمیزی نشده‌اند کمینه می‌شود و همچنین احتمال وجود یک راه‌حل بدون تضاد وجود دارد.

            در ابتدای تکنیک جستجوی محلی، رئوس در $P$ بر اساس ارزش وزنی خود به ترتیب نزولی مرتب می‌شوند تا رئوس با بیشترین وزن اولویت داشته باشند، اگر امکان وجود داشته باشد. برای هر $v_p$ در $P$، الگوریتم مجموع وزن رئوس با $v_p$ در همه‌ی $k$ کلاس $S_0$ را محاسبه کرده و کمینه مجموع را پیدا می‌کند. اگر این مقدار کمتر از $w(v_p)$ باشد، عملیات جابجایی انجام می‌شود. رئوس در کلاس رنگی به $P$ پرتاب شده و $v_p$ به کلاس رنگی منتقل می‌شود. اگر چنین کلاسی وجود نداشت، $v_p$ از $P$ حذف شده و در یک لیست ممنوعه $V_{tabu}$ قرار می‌گیرد که رئوس رنگ‌آمیزی نشده برای $S_0$ را نگه می‌دارد. جستجوی محلی ادامه می‌یابد تا هر $v_p$ در $P$ پردازش شود و $P$ خالی شود. همه‌ی رئوس رنگ‌آمیزی نشده در $V_{tabu}$ حضور دارند، بنابراین این لیست می‌تواند در محاسبه تناسب فرزند استفاده شود که در زیربخش بعدی شرح داده شده است. در نهایت، رئوس در $V_{tabu}$ به صورت تصادفی به کلاس‌های رنگی اختصاص داده می‌شوند.

            شکل 5 تکنیک جستجوی محلی پیشنهادی را با استفاده از گراف داده شده در شکل 4 نشان می‌دهد. فرض کنید عملگر جابجایی یکپارچه روی دو تنظیمات والدین اعمال شده و یک فرزند با پول غیرخالی به دست آمده است. در $P$ رئوس 9 دارد بنابراین جستجوی محلی به منظور قرار دادن این رئوس در یکی از کلاس‌های رنگی برای کمینه کردن مجموع وزن رئوس رنگ‌آمیزی نشده است. در $C_0$، رأس 9 با رأس 3 که وزن آن 1 است درگیری دارد که کمتر از وزن رأس 9 است، بنابراین رأس 3 در $V_{spilled}$ ذخیره شده و مقدار کمینه به عنوان 1 تنظیم می‌شود. در $C_1$، رئوس 1 و 8 با رأس 9 درگیری دارند و مجموع ارزش وزن آن‌ها 5 است که بیشتر از حداقل است بنابراین $C_1$ برای رأس 9 مناسب نیست. در نهایت، در $C_2$ رأس 4 و رأس 9 با یکدیگر درگیری دارند و وزن رأس 4 برابر با 3 است که دوباره بیشتر از مقدار کمینه است. تمامی کلاس‌های رنگی بازدید شده و رأس 9 از $P$ حذف شده و به $C_0$ انتقال داده می‌شود، در حالی که رأس 3 در $V_{spilled}$ حذف شده و به $P$ انتقال می‌یابد. از آنجا که $P$ خالی نیست، کلاس‌های رنگی برای رأس 3 بازدید می‌شوند. رأس 3 در تمام کلاس‌های رنگی درگیری دارد و کمترین وزن را دارد، بنابراین رأس 3 در $V_{tabu}$ قرار می‌گیرد. $P$ خالی می‌شود، بنابراین W-SWAP کامل می‌شود.

        \subsection{عملکرد تناسب اندام}

            تابع تلفیق به عنوان مجموع وزن رئوسی که رنگ‌آمیزی نشده‌اند، به عبارت دیگر رئوس حاضر در $V_{tabu}$ پس از اتمام تکنیک جستجوی محلی محاسبه می‌شود. بهترین سناریو این است که لیست $V_{tabu}$ خالی باشد که به این معناست که همه رئوس با $k$ رنگ رنگ‌آمیزی شده‌اند و مقدار تابع تلفیق $f(k)$ برابر با صفر است. در شکل 5، رأس 3 برای تمامی کلاس‌های رنگی $S_0$ تابو می‌شود و مقدار تابع تلفیق $S_0$ به وزن رأس 3 که برابر با 1 است اختصاص داده می‌شود.

            شکل 6 نمایش‌دهنده حل‌های الگوریتم‌ها در پایان عملیات جستجوی محلی است. هر دو الگوریتم HEA و COMA نمی‌توانند دو رأس با وزن کل 4 را به کلاس‌های رنگی اختصاص دهند، بنابراین مقدار تابع تلفیق این حل‌ها 4 است. PBEA و InCEA فقط یک رأس بدون رنگ دارند و رأس 3 کمترین وزن را دارد، بنابراین کار پیشنهادی کمترین مقدار تابع تلفیق را با مقدار 1 به دست می‌آورد، در حالی که PBEA یک حل با مقدار تابع تلفیق 2 تولید می‌کند.

            اگر مقدار تابع تلفیق حاصله برای فرزند بهتر از یکی یا هر دوی والدین باشد، الگوریتم والدین را با بدترین مقدار تابع تلفیق انتخاب کرده و فرزند را با این والدین در جایگزینی جابجا می‌کند.

    \section{مطالعه تجربی}
            
        در این بخش، عملکرد کار پیشنهادی با استفاده از گراف‌های تصادفی و گراف‌های مشتق شده از بنچمارک‌های DIMACS با HEA، COMA و کار اولیه ما با نام PBEA مقایسه می‌شود. برای هر گراف، هزینه کل، تعداد راس‌هایی که رنگ نشده‌اند و زمان اجرای الگوریتم‌ها از معیارهای مقایسه اصلی هستند.

        آزمایش‌ها بر روی یک کامپیوتر با پردازنده  4770 i7 Core Intel با فرکانس 3.4 گیگاهرتز و 8 گیگابایت حافظه RAM انجام شد. پیاده‌سازی InCEA در زبان برنامه‌نویسی $C^1$ است و با استفاده از gcc کامپایل شده است. همچنین HEA و COMA در $^2$C++ پیاده‌سازی شده و با استفاده از g++ کامپایل شده‌اند. استفاده از زبان‌های برنامه‌نویسی مختلف برای پیاده‌سازی الگوریتم‌ها می‌تواند به عنوان یک تهدید برای اعتبارسنجی [50] در نظر گرفته شود به منظور به‌دست آوردن زمان اجرای دقیق الگوریتم‌ها.

        هر دو HEA و COMA یک فرزند را در پایان مرحله تلاقی ایجاد می‌کنند و سعی می‌کنند این فرزند را در مرحله جستجوی محلی بهبود دهند. بنابراین همه الگوریتم‌ها یک فرد در یک تکرار ایجاد می‌کنند. از آنجا که تمام الگوریتم‌ها با استفاده از همان اندازه جمعیت و همان تعداد تکرارها ارزیابی می‌شوند، تعداد ارزیابی‌های تابع تناسب [50] توسط الگوریتم‌ها برابر است، به جز آزمایشی که با استفاده از یک محدودیت زمان ثابت انجام شده است. برای این آزمایش، تعداد تکرارهای استفاده شده توسط تمام الگوریتم‌ها را نیز ارائه داده‌ایم. برای آزمایش‌های زیر، تمام الگوریتم‌ها پارامترهای یکسانی را دریافت می‌کنند و هیچ‌کدام از آن‌ها از پارامترهای کنترل یا تنظیم‌کننده‌هایی مانند ،REVAC F-Race یا CRS-Tuning استفاده نمی‌کنند.

        معیارهای عملکرد عملگرها در الگوریتم ما را برای ارزیابی، کار ارائه شده را با مطالعه اولیه ما PBEA [47] با استفاده از سه نمودار که $n = 500$ و $\alpha = \{0.25، 0.60، 0.90\}$ مقایسه کرد. عملکرد الگوریتم‌ها با و بدون استفاده از تکنیک‌های جستجوی محلی آن‌ها اندازه‌گیری شد. بنابراین، PBEA و InCEA که فقط با عملگرهای تراکم کار می‌کنند به ترتیب به عنوان PBC و InCX مشخص می‌شوند. عملکرد الگوریتم‌ها 20 بار در هر گراف با استفاده از 20 کلاس رنگ ارزیابی شد. مقایسه عملکرد الگوریتم‌ها از نظر ارزش‌های تناسب و تعداد رأس‌های بدون رنگ در شکل 7 نشان داده شده است. زمانی که ارزش‌های تناسب آن‌ها را مدنظر قرار دهیم، عملگر تراکم ارائه شده InCX به کمک عملیات جستجوی معکوس، عملگر PBC را پیشتیبانی می‌کند اما PBEA با تکنیک جستجوی محلی خود InCX را پیشتیبانی می‌کند. انتظار می‌رود که از آنجایی که InCX وزن رئوس را در نظر نمی‌گیرد اما به دنبال به دست آوردن بزرگترین گروه رأس غیر تعارضی است، این عملکرد را انجام دهد. وزن رئوس رنگارنگ را در تکنیک جستجوی محلی پیشنهادی ما (W-SWAP) می‌تواند افزایش دهد. از طرف دیگر، با هدف کاهش مقدار ارزش تناسب، رویکرد ما بهترین مقدار ارزش تناسب را در تمام موارد آزمایشی ارائه شده دارد.

        زمانی که تعداد رئوس بدون رنگ مدنظر قرار گرفته است، این تعداد در InCEA نسبت به InCX بیشتر است، زیرا هدف تکنیک جستجوی محلی جدید ما از کاهش مقدار ارزش تناسب است. بنابراین، ممکن است با جایگزینی یک رأس بدون رنگ با وزن بالاتر با بیش از یک رأس دارای مجموع وزن کمتر، تعداد رئوس بدون رنگ افزایش یابد. بنابراین این ممکن است تعداد رئوس بدون رنگ را افزایش دهد تا مقدار ارزش تناسب را کاهش دهد. InCX با موفقیت بزرگترین گروه رئوس غیر تعارضی را به دست می‌آورد و تعداد کمتری از رئوس بدون رنگ را باقی می‌گذارد. از طرف دیگر، PBC و PBEA بیشترین تعداد رئوس را می‌پاشند زیرا هنگامی که کلاس‌های رنگ از طریق عملگرهای تراکم ساخته می‌شوند، اعضا آن‌ها ثابت هستند که باعث کاهش فضای جستجوی راه‌حل می‌شود.

        \subsection{نمودارهای تولید شده به صورت تصادفی}

            برای تولید گراف‌های تصادفی یک مولد گراف تصادفی پیاده‌سازی شده است که از سه پارامتر ورودی استفاده می‌کند. این پارامترها شامل تعداد رئوس $n$، محدوده‌ای از ارزش‌های وزن $\gamma$ برای اختصاص ارزش‌های وزن به رئوس، و چگالی لبه $\alpha$ برای تولید لبه‌های اتصال بین رئوس است.

            تعداد کل لبه‌ها در گراف‌های تولید شده به نزدیکی به 
            $(n \times (n-1)) \div 2 \times \alpha$
            است. از آنجا که لبه‌ها به صورت تصادفی ایجاد می‌شوند، برای مقادیر کم چگالی لبه، ممکن است برخی از رئوس جدا شوند، بنابراین هیچ تضمینی برای به دست آوردن گراف‌های متصل وجود ندارد. مولد گراف ما یک لبه بین دو راس جدا شده را که به صورت تصادفی انتخاب شده‌اند، اضافه می‌کند. پس از ساخت گراف، ارزش‌های وزن رئوس به صورت تصادفی با استفاده از توزیع یکنواخت تنظیم می‌شوند.

            الگوریتم‌ها با استفاده از تعداد ثابت و پیش‌فرضی از کلاس‌های رنگ برای گراف‌های تولید شده آزمایش می‌شوند. تعداد کلاس‌های رنگ برابر با $(n \times \beta)$ است، جایی که $\beta$ چگالی کلاس‌های رنگ است. محدوده مقادیر برای پارامترهای تولید گراف و چگالی کلاس‌های رنگ در جدول 1 لیست شده است.

            \subsubsection{تنظیمات پارامترهای الگوریتم‌ها}

                به عنوان بخشی از مطالعه آزمایشی ما، عملکرد الگوریتم‌ها با استفاده از گراف‌های مختلف برای تنظیم اندازه جمعیت الگوریتم‌ها و تعداد تکرارهای انجام شده توسط الگوریتم‌ها اندازه‌گیری شده است. نتایج نشان می‌دهند که عملکرد الگوریتم‌ها به اندازه اولیه جمعیت بستگی ندارد، بنابراین برای تمام الگوریتم‌ها به 100 تنظیم شده است.

                تأثیر تعداد تکرار برای HEA، COMA و InCEA بر روی یک گراف با $n = 500$ و $\alpha = 0.90$ مشاهده شده است. گراف تولید شده تقریباً کاملاً متصل است، بنابراین الگوریتم‌ها برای به دست آوردن بهترین نتایج خود نیاز به بیشترین تعداد تکرار دارند. عملکرد الگوریتم ما پس از تکرار 1000 ایستا می‌ماند، اما HEA و COMA پس از تکرار 200 به بهترین نتایج خود می‌رسند. بنابراین، ما تعداد تکرار را برای همه الگوریتم‌ها به 1000 تنظیم می‌کنیم. در بقیه آزمایش‌ها، اندازه جمعیت و تعداد تکرارها به ترتیب به 100 و 1000 تنظیم شده است مگر اینکه خلاف آن ذکر شده باشد.

                عملکرد الگوریتم‌ها برای جفت $(n، \alpha)$ با ارزش‌های متغیر $\beta$ در جدول 2 و جدول 3 نشان داده شده است. هر ردیف در جدول 2 نتایج میانگین به دست آمده از 125 مورد آزمایش را نشان می‌دهد. با افزایش مقدار $\alpha$، تعداد بیشتری از یال‌ها بین راس‌ها به گراف اضافه می‌شود و این باعث افزایش هم تعداد راس‌های بدون رنگ و هم مقدار تناسب الگوریتم‌ها می‌شود. این همچنین باعث افزایش زمان اجرا می‌شود، زیرا فضای جستجوی الگوریتم‌ها افزایش می‌یابد. این روند را می‌توان با استفاده از نتایج به دست آمده از عملکرد الگوریتم‌ها به راحتی مشاهده کرد. نتایج نشان می‌دهد که الگوریتم پیشنهادی نسبت به دو الگوریتم از ادبیات از نظر مقدار تناسب، تعداد راس‌های بدون رنگ و زمان اجرای کل بهتر عمل می‌کند.

            \subsubsection{ارزیابی عملکرد الگوریتم‌ها}

                عملکرد HEA، COMA و InCEA بر روی گراف‌های تصادفی با ویژگی‌های مختلف ارزیابی می‌شود. برای هر ترکیب از $n$ و $\alpha$ که در جدول 1 آمده است، پنج گراف تصادفی ایجاد می‌شود. بنابراین، کلیه 150 گراف مختلف برای اندازه‌گیری عملکرد الگوریتم‌ها با پنج مقدار مختلف $\beta$ استفاده می‌شود. برای 750 مورد آزمایش، الگوریتم‌ها در این بخش پنج بار اجرا می‌شوند.

                جدول 3 مقایسه‌ای جفتی انجام می‌دهد با استفاده از دو ستون، و هر ستون نشان‌دهنده تعداد کل موردهای آزمایش (از 125 مورد) است که الگوریتم اول میزان بهتر، برابر یا بدتری نسبت به الگوریتم دوم را دارد. وقتی $\alpha$ برابر با 0.10 باشد، الگوریتم‌ها حداقل در 60٪ از موارد آزمایشی نتایج یکسانی را دریافت می‌کنند زیرا گراف‌ها تقریباً خالی از یال هستند. الگوریتم پیشنهادی در بیشتر موارد آزمایشی نتایج بهتری نسبت به هر دو HEA و COMA دارد هنگامی که مقدار $\alpha$ افزایش می‌یابد. در ستون سوم، تعداد موارد آزمایشی که همه رأس‌ها می‌توانند رنگ‌آمیزی شوند آمده است. تعداد رنگ‌هایی که الگوریتم‌ها استفاده می‌کنند به نسبت $n$ است؛ بنابراین برای ارزیابی‌های با ارزش $n$ بزرگتر، تعداد کل موارد آزمایشی که الگوریتم‌ها می‌توانند تمام رأس‌ها را رنگ‌آمیزی کنند افزایش می‌یابد. وقتی $\alpha = \{0.75, 0.90\}$، گراف تقریباً کاملاً متصل است؛ بنابراین در هیچ یک از موارد آزمایشی، الگوریتم‌ها قادر به رنگ‌آمیزی تمام رأس‌های گراف نیستند. الگوریتم پیشنهادی به ترتیب در 75٪ و 76٪ از کل موارد آزمایشی HEA و COMA را پیش می‌گیرد. الگوریتم پیشنهادی در 36٪ از موارد آزمایشی توانسته است تمام رأس‌ها را رنگ‌آمیزی کند، در حالی که نتایج برای COMA و HEA هر دو 17٪ است.

                کارایی الگوریتم‌ها نیز برای جفت $(n, \beta)$ با ارزش‌های متغیر $\alpha$ ارزیابی می‌شود. مقادیر پایین‌تر $\beta$ نشان‌دهنده استفاده کمتر از تعداد رنگ‌ها توسط الگوریتم‌ها است، بنابراین هم ارزش فیتنس و هم تعداد رأس‌های بدون رنگ برای مقادیر پایین $\beta$ بالا است، همانطور که در جدول ۴ قابل مشاهده است. عملکرد الگوریتم‌ها برای هر جفت $(n, \beta)$ اندازه‌گیری شده و در هر ردیف، نتایج میانگین (از بین 150 مورد آزمایشی) برای فیتنس و تعداد رأس‌های بدون رنگ داده شده است. کار پیشنهادی ما در هر ردیف بهترین نتایج را به دست می‌دهد.

                در جدول 5، مقایسه دو به دوی الگوریتم‌ها آورده شده است. برای مقادیر ($\beta$) بزرگ‌تر، تعداد رنگ‌های استفاده شده توسط الگوریتم‌ها افزایش می‌یابد و این منجر به اختصاص بیشتر رأس‌ها به رنگ‌های داده شده می‌شود. الگوریتم ما بیشترین تعداد موردهای آزمایشی را دارد که تمام رأس‌ها با موفقیت رنگ‌آمیزی شده‌اند.

                در کار پیشنهادی ما، رأس‌های غیر رنگ‌آمیزی شده که کمترین مقدار تابع فیت‌نس را حاصل می‌کنند، پس از اتمام تکنیک جستجوی محلی در $V_{tabu}$ ذخیره می‌شوند. بنابراین، الگوریتم ما نیازی به محاسبات اضافی برای یافتن بهترین رأس(ها) برای بدون رنگ کردن کمترین مقدار فیت‌نس ندارد. اما در HEA و COMA، یک جستجوی کامل در تکنیک جستجوی محلی و در انتخاب رأس‌های بدون رنگ برای محاسبه فیت‌نس وجود دارد، به همین دلیل زمان اجرای الگوریتم پیشنهادی به طور قابل توجهی بهتر از HEA و COMA است که به وضوح از جداول 2 و 4 مشهود است.

        \subsection{معیارهای DIMACS}
            
            با توجه به توضیحات، این 73 نمونه از نمودارهای DIMACS دارای پنج نوع مختلف هستند که برای مسأله رنگ‌آمیزی گراف با وزن رأس استفاده می‌شوند. نمودارهایی که برای مسأله تخصیص ثبت نام به منابع ایجاد شده‌اند با نام 
            \texttt{g\{b\}*.col"$\alpha$"Rn\_}
            نشان داده می‌شوند. نمودارهای GEOM نمودارهای هندسی هستند و با 
            \texttt{"GEOM\{a,b\}n.col"}
            نشان داده می‌شوند که $a$ و $b$ به درصد چگالی متناظر می‌انجامد. نمودارهای queen با استفاده از مسأله صفحه شطرنج nxn ایجاد می‌شوند، که با
            \texttt{"queenn\_n.col"}
            نمایش داده می‌شوند. نمودارهای DSJC نمودارهای تصادفی برای مسأله انجمن‌سازی تقلیدی هستند و با 
            \texttt{g\{b\}*.col"$\alpha$"DSJCn\_}
            نشان داده می‌شوند. نمودارهای myciel بر اساس تبدیل Mycielski ایجاد می‌شوند و با
            \texttt{"myciel\{5,6,7\}g\{b\}*.col"}
            نشان داده می‌شوند. در نام‌های نمودارهای ،R ،myciel queen و ،DSJC محدوده وزن رأس‌ها با 
            \texttt{"g"}
            $(\gamma = [1..5])$ یا 
            \texttt{"gb"}
            $(\gamma = [1..20])$ نمایش داده می‌شود.

            برای آزمایش‌های مربوط به مجموعه داده‌های DIMACS، ابتدا کمترین مقدار $k$ برای هر الگوریتم برای به دست آوردن یک k-رنگ‌آمیزی معتبر یافت می‌شود. آزمایش‌ها با مقدار کافی بزرگی از $k$ شروع می‌شود و $k$ کاهش می‌یابد تا یک راه‌حل غیرقانونی پیدا شود که برخی از رأس(ها) از گراف‌ها رنگ‌آمیزی نشده‌اند. کمترین $k$ که توسط الگوریتم‌ها یافت می‌شود به عنوان حداقل تعداد رنگ استفاده شده توسط الگوریتم‌ها مشخص می‌شود. یک‌بار که بهترین مقدار $k$ ($k_{best}$) برای هر نمونه یافت شود، عملکرد الگوریتم‌ها با استفاده از سناریوهای مختلف اندازه‌گیری می‌شود.

            جدول 6 و جدول 7 مقایسه عملکرد الگوریتم‌ها روی 73 مثال از مجموعه داده‌های DIMACS را ارائه می‌دهند، جایی که هر الگوریتم پنج بار اجرا شده است تا بهترین نتیجه با استفاده از 30000 تکرار به دست آید. نام گراف، تعداد رأس و تعداد یال‌ها در گراف‌ها در سه ستون اول جداول ذکر شده است. برای هر الگوریتم، تعداد کمینه رنگ‌های استفاده شده و زمان اجرا در دو ستون جداگانه لیست شده است. از سوی دیگر، ستون مشخص شده توسط $\Delta_1$ در جداول اختلاف بین تعداد رنگ‌های استفاده شده توسط الگوریتم InCEA و HEA را نشان می‌دهد، یعنی $k_{InCEA} - k_{HEA}$. به طور مشابه، ستون $\Delta_2$ اختلاف $k_{InCEA} - k_{COMA}$ را برای گراف‌های مورد بررسی در آزمایش‌های ما نشان می‌دهد.

            InCEA در 30٪ و 33٪ از نمونه‌ها، نسبت به HEA و COMA عملکرد بهتری داشته است، در حالی که در سه نمونه، به نام‌های \texttt{queen10\_10g.col}، \texttt{queen10\_10gb.col} و \texttt{GEOM120a.col}؛ InCEA از یک رنگ اضافی استفاده کرده است. برای این سه نمونه، ما علاوه بررسی موردی برای رفتار الگوریتم‌ها، سه نمونه‌ی دیگر \texttt{R100\_1gb.col}، \texttt{R100\_5gb.col} و \texttt{R100\_9gb.col} را اضافه کرده‌ایم که InCEA نتایج بهتری به دست آورده است. برای این شش نمونه، الگوریتم‌ها 20 بار با استفاده از $k_{best}$، مقادیر تناسب و تعداد رأس‌های غیر رنگ‌آمیز را نشان می‌دهند در شکل 8 و شکل 9 به ترتیب. به عنوان مثال، تعداد کمینه رنگ‌های استفاده شده توسط HEA و COMA برای رنگ‌آمیزی \texttt{R100\_1gb.col} برابر 6 است، در حالی که InCEA با استفاده از 5 رنگ موفق به رنگ‌آمیزی این نمونه شده است. بنابراین، $k_{best}$ برای به دست آوردن یک رنگ‌آمیزی قانونی $k$ برای این نمونه 5 است، و تمامی الگوریتم‌ها با استفاده از 5 تعداد کلاس رنگی اجرا می‌شوند. ارزش تناسب برای یک راه‌حل مجاز صفر است، در صورتی که یک راه‌حل نامجاز یافت شود، سپس ارزش تناسب الگوریتم به عنوان مجموع وزن رأس(ها) رنگ‌آمیزی نشده محاسبه می‌شود.

            

\end{document}
